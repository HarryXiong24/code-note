

---

Easy

## 1. 删列造序

- 来源： **leetcode 944**
- 思路：将所有逆序的列添加到D中即可

## 2. 最后一块石头的重量

- 来源： **leetcode 1046**
- 思路： 每次都将 stones 最后两个元素相减，并且删除适当 stones 元素

## 3. 买卖股票的最佳时机2

- 来源： **leetcode 122**
- 思路： 采用邻位相减的方法得到一个数组， 然后将该数组中所有大于0的数相加就得到了最终的结果
## 4. 两地调度

- 来源： **leetcode 1029**
- 思路： 先将所有 costs 按照差值排序，然后将前N个去A城， 后N个去B城。

## 5. 柠檬水找零

- 来源： **leetcode 860**


## 6. 分发饼干
- 来源： **leetcode 455**

- 思路：
> 1. 对需求因子g与糖果大小s进行从小到大排序
> 2. 按照从小到大的顺序使用糖果测试是否满足某个孩子；每个糖果只尝试一次；若成功，则换一个孩子；直到没孩子或没糖果


## 7. k次取反后最大化的数组和

- 来源： **leetcode 1005**
- 思路： 进行k次，每一次都对最小的元素取反

## 8. 模拟行走机器人 

- 来源：leetcode 874
- 思路：



---

**Medium 级别**

## 1. 翻转矩阵后得分

- 来源： **leetcode 861**
- 题目： 有一个二维矩阵 A 其中每个元素的值为 0 或 1 。移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。返回尽可能高的分数。

## 2. 使括号有效的最少添加

- 来源： **leetcode 921**

- 题目：**给定一个由 '(' 和 ')' 括号组成的字符串 S，我们需要添加最少的括号（ '(' 或是 ')'，可以在任何位置），以使得到的括号字符串有效。给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。**

- 说明：只有满足下面几点之一，括号字符串才是有效的：
> - 它是一个空字符串
> - 它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串
> - 它可以被写作 (A)，其中 A 是有效字符串。

## 3. 划分字母空间

- 来源： **leetcode 763**
- 问题：字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。
- 贪心思想： 先获得每个字母最后一次出现的位置， 然后从前向后遍历字符串， 维护一个区间[start, end]：
  > - 如果在该区间的字符最后一次出现的位置比当前区间end更大， 则，更新区间的end
  > - 如果遍历到字符位置出了区间，则需要重新设置区间

## 4. 摆动序列 

- 来源： **leetcode 376**

- 题目： 一个整数序列，如果两个相邻元素的差恰好正负（负整）交替出现，则该序列被称为摇摆序列。 一个小于2个元素的序列直接为摇摆序列。给定一个整数序列，返回作为摆动序列的最长子序列的长度。可以删除原始序列中的一些元素来获得子序列，剩下的元素保持其原始顺序。

- 举例： [1,7,4,9,2,5]， 相邻元素差[6,-3,5, -7,3]， 该序列为摇摆序列
  [1,17,5,10,13,15,10,5,16,8]， 其最终的子序列为[1,17,10,13,10,16,8]，子序列长度为7

### 贪心规律
当序列有一段连续的递增（或递减）时，为形成摇摆子序列，我们只需要保留这段连续的递增（或递减）的首尾元素，这样更可能使得尾部的后一个元素称为摇摆子序列的下一个元素。 简单来说，就是只选择转折点的元素。

![](http://ww1.sinaimg.cn/large/006gOeiSly1g128uib1lqj30ga07pmy7.jpg)

### 思路1

采用一个变量 pre_flag 记录上一次的正负，采用pre_val 来记录数组的上一个元素。 

先获得当前的正负标志，然后与之前的正负标志 pre_flag 比较，如果相同，则接着遍历下一个元素，如果不同，则更改标志，接着遍历。

### 思路2

采用状态机的思想， 设置为3个状态： BEGIN, UP, DOWN 三个状态， BEGIN 表示的是初始时的状态， UP 表示的是递增的状态， DOWN 表示的是递减的状态，只有当状态发生变化的时候，摇摆序列的长度才加一。


## 5. 移掉k位数字

- 来源：**leetcode 402**

- 题目：已知一个使用字符串表示的非负整数num，将num中的k个数字移除，求移除k个数字后，可获得的最小的可能的新数字。

- 说明： num 的长度小于 10002 且 ≥ k。num 不会包含任何前导零。

### 分析

一个长度为n的数字，去掉k个数字，有 C(k,n) = n!/((n-m)! * m!)， 因此使用枚举是不行的。

思考： 对于数字1432219， k=1， 我们只去掉一个数字，应该去掉哪个？ 如果 k > 1 ，我们应该按照什么顺序与策略进行删除数字，得到的结果最优？

分析： 若只去掉一个数字，为了使得得到的新数字最小，需要尽可能让新数字的最高位最小，其次是次高位最小，以此类推。

### 思路

从高位向低位遍历，如果对应的数字大于下一位数字，则把该位数字去掉，得到的数字最小。

使用栈存储最终结果和删除工作，从高位向低位遍历num， 如果遍历的数字大于栈顶元素，则将该元素push入栈， 如果小于栈顶元素，则进行pop， 直至栈为空或不能再删除数字或者栈顶小于当前元素为止。

## 6. 跳跃游戏

- 来源：**leetcode 55**
- 问题： 给定一个非负整型数组nums，nums[i]表示可以从数组第i个位置最多向前跳跃nums[i]步；求是否可以从数组第0个位置跳跃到数组的最后一个元素的位置？

- 举例： [2, 3, 1, 1, 4]， 返回true

### 分析

如果此时处在第i个位置，该位置最远可以跳至第j位置(index[i])， 故第i位置还可跳至第 i+1, ... j-1,j位置；那么此时我们应该选择 index[i+1], ...index[j] 中最大的那个。

### 思路

从头到尾的遍历，找到最远能走到的位置

- 求从第i位置最远可跳至第index[i]位置： index[i] = nums[i] + i
- jump 表示当前所处的位置，初始化为0
- 设置变量max_index 表示从第0个位置直至jump位置这个过程中，最远可达到的位置，初始化为index[0]
- 利用jump扫描index数组，直到jump达到index数组尾部或者jump超过max_index， 扫描过程中，更新 max_index
- 若最终jump为数组长度，则返回true，否则，返回false

## 7. 射击气球

- 来源： **leetcode 452**
- 问题： 在一个平面上有一定数量的气球，平面可以看做一个坐标系， 在平面的x轴的不同位置安排弓箭手向y轴方向射箭，弓箭可以向y轴走无穷远； 给定气球宽度 xstart <= x <= xend， 问至少需要多少弓箭手，才能将全部气球打爆？
- 举例： 气球: [[10,16], [2,8], [1,6], [7, 12]]， 至少需要2名弓箭手

### 思路

现将数组按照第一个元素排序， 维护一个射击范围，该射击范围表示几个球的重叠部分。 如果新球不在这个重叠范围内，则 弓箭手+1，更新重叠范围； 否则，更新重叠范围即可。

## 8. 任务调度器

- 来源： **leetcode 621**
- 思路：贪心算法

## 9. 会议室 2

- 来源： **leetcode 253**

- 思路1： 优先队列

  > - 按照开始时间对会议进行排序
  >
  > - 初始化一个最小堆，将第一个会议结束时间加入堆中。
  >
  > - 对于每个会议，检查堆的最小元素是否空闲：
  >
  >   > > - 若空闲，则从堆顶拿出该元素，将其改为我们处理的会议的结束时间，加回到堆中
  >   > > - 若房间不空闲，则开新房间，并加入堆中
  >
  > - 处理完所有会议后，堆的大小即为开的房间数量

- 思路2： 有序化

---

Hard

## 1. 跳跃游戏2

- 来源：leetcode 45
- 问题： 给定一个非负整型数组nums，nums[i]表示可以从数组第i个位置最多向前跳跃nums[i]步；确认可以从第0个位置跳跃到最后一个位置，求最少需要跳跃几次？

### 分析

在无法到达更远位置时，在这之前应该跳到一个可以到达更远位置的位置。

### 思路

- 设置current_max_index 为当前可达到的最远位置
- 设置pre_max_max_index 为在遍历各个位置的过程中，各个位置可达到的最远位置
- jump_min 为最少跳跃的次数
- 利用i遍历nums数组，若i超过 current_max_index, jump_min +1， current_max_index = pre_max_max_index
- 遍历过程中，若 nums[i] + i 更大，则更新 pre_max_max_index = nums[i] + i

